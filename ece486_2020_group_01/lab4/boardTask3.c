/*
 **@file
 *
 *@brief ECE 486 modulation board code
 *
 *@author ECE486 Lab Group 1
 *@author John Bowen, Jeremy Juybari, Nate McNutt, Annalyse Nichols
 *
 *@date april 2020.
 *
 * Program to flash the board.
 */

#include "stm32l4xx_hal.h"
#include "stm32l476g_discovery.h"

#include "ece486.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "ece486_nco.h"
#include <stdint.h>
#include "arm_math.h"
#include "keying.h"


extern FlagStatus KeyPressed;   // Use to detect button presses

int main(void)
{
  int nsamp;
  float *input, *output1, *output2;
  static int button_count = 0;
  /*
   * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
   *
   * If your discovery board has been modified to support the external
   * HSE reference, use the (better quality crystal controlled) HSE
   * configuration.  If not, you can use the MSI reference, and things
   * should still work -- but your clocks will drift over time.
   *
   * The MSI (Medium speed internal) reference is the on-chip RC oscillator
   *
   * The HSE (High speed external) reference is an external clock, either
   * provided through the external connector, or (if your board is modified)
   * from the crystal reference source generated by the other processor
   * on the development board.
   */
  //initialize_ece486(FS_50K, MONO_IN, STEREO_OUT, MSI_INTERNAL_RC);
  initialize_ece486(FS_200K, MONO_IN, STEREO_OUT, HSE_EXTERNAL_8MHz);

  /*
   * Allocate Required Memory
   */
  nsamp = getblocksize();
  input = (float *)malloc(sizeof(float)*nsamp);
  output1 = (float *)malloc(sizeof(float)*nsamp);
  output2 = (float *)malloc(sizeof(float)*nsamp);

  // Initialize 2 NCOs for 2 waveforms (cosine & sine)
  NCO_T *s1 = init_nco(0.058, 0.0);	
  NCO_T *s2 = init_nco(0.058, 3*M_PI/2);

  // Set scale factor such to not overflow the DAC
  s1->amp = 0.9;
  s2->amp = 0.9;

  // Set up keying with target bit pattern, number of bits to encode, and rate
  int bit_pattern[] = {0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,1,1};
  int pattern_length = 20;
  int bit_rate = 1000;

  // Initialize the bit keying struct
  BP_T *b = keying_init(bit_pattern, pattern_length, bit_rate);

  // Check for memory allocation errors
  if (input==NULL||output1==NULL||output2==NULL) {
    flagerror(MEMORY_ALLOCATION_ERROR);
    while(1);
  }

  /*
   * Normally we avoid printf()... especially once we start actually
   * processing streaming samples.  This is here to illustrate the
   * use of printf for debugging programs.
   *
   * To see the printf output, connect to the ST-Link serial port.
   * Use: 115200 8N1
   */
  printf("Starting execution using %d samples per input block.\n",nsamp);
  /*
   * Infinite Loop to process the data stream, "nsamp" samples at a time
   */
  while(1){
    /*
     * Ask for a block of ADC samples to be put into the working buffer
     *   getblock() will wait here until the input buffer is filled...  On return
     *   we work on the new data buffer... then return here to wait for
     *   the next block
     */
    getblock(input);

    /*
     * signal processing code to calculate the required output buffers
     */

    DIGITAL_IO_SET(); 	// Use a scope on PD0 to measure execution time

	// Code to switch between methods of encoding based on button presses
	switch (button_count) {
		case 0: // On-Off Keying
			ook(s1, b);
			nco_get_samples(s1, output1, nsamp);
			break;

		case 1: // Amplitude Shift Keying
			ask(s1, b);
			nco_get_samples(s1, output1, nsamp);
			break;

		case 2: // Binary Phase Shift Keying
			bpsk(s1, b);
			nco_get_samples(s1, output1, nsamp);
			break;

		case 3: // Quadrature Phase Shift Keying
			qpsk(s1, s2, b, output1, output2);
			break;
	}

    DIGITAL_IO_RESET();	// (falling edge....  done processing data )

    /*
     * pass the processed working buffer back for DAC output
     */
    putblockstereo(output1, output2);

    // Cycle through modulation types by pushing the button
    if (KeyPressed) {
	KeyPressed = RESET;
	button_count++;

	// If no more encoding types then restart
	if (button_count > 3) {
		button_count = 0;
	}

	// Clear the LCD display
	BSP_LCD_GLASS_DisplayString((uint8_t *)"        ");
	
	// Draw to the display the correct method of keying
	switch (button_count) {
		case 0:
			// OOK
			BSP_LCD_GLASS_DisplayString((uint8_t *)"OOK");
			break;
		case 1:
			// ASK
			BSP_LCD_GLASS_DisplayString((uint8_t *)"ASK");
			break;
		case 2:
			// BPSK
			BSP_LCD_GLASS_DisplayString((uint8_t *)"BPSK");
			break;
		case 3:
			// QPSK
			BSP_LCD_GLASS_DisplayString((uint8_t *)"QPSK");
			
			// Reset the waveform indices and phases
			// QPSK seems more sensitive to changes that other
			// keying methods left over.
			s1->ctrlWord = 0;
			s2->ctrlWord = 0;
			nco_set_phase(s1, 0.0);
			nco_set_phase(s2, 3*M_PI/2);

			// Reset position within bit pattern and block counts
			b->pos = 0;
			b->block_count = 0;

			break;

	}

    }
  }

}
