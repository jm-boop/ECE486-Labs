/*
 **@file
 *
 *@brief ECE 486 IRR filter code
 *
 *@author ECE486 Lab Group 1
 *@author John Bowen, Jeremy Juybari, Nate McNutt, Annalyse Nichols
 *
 *@date Febuary 2020.
 *
 * Program to flash the board. 
 */

#include "stm32l4xx_hal.h"
#include "stm32l476g_discovery.h"

#include "ece486.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "ece486_biquad.h"
#include <stdint.h>
#include "arm_math.h"

extern FlagStatus KeyPressed;   // Use to detect button presses

int main(void)
{
  uint32_t nsamp;
  float32_t *input, *output1, *output2;

  /*
   * Set up ADCs, DACs, GPIO, Clocks, DMAs, and Timer
   *
   * If your discovery board has been modified to support the external
   * HSE reference, use the (better quality crystal controlled) HSE
   * configuration.  If not, you can use the MSI reference, and things
   * should still work -- but your clocks will drift over time.
   *
   * The MSI (Medium speed internal) reference is the on-chip RC oscillator
   *
   * The HSE (High speed external) reference is an external clock, either
   * provided through the external connector, or (if your board is modified)
   * from the crystal reference source generated by the other processor
   * on the development board.
   */
  //initialize_ece486(FS_50K, MONO_IN, STEREO_OUT, MSI_INTERNAL_RC);
  initialize_ece486(FS_48K, MONO_IN, STEREO_OUT, HSE_EXTERNAL_8MHz);

  /*
   * Allocate Required Memory
   */
  nsamp = getblocksize();
  input = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output1 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  output2 = (float32_t *)malloc(sizeof(float32_t)*nsamp);
  //float32_t biquad_coefs[] = {1.0, 1.618, 1.0, -1.5371, 0.9025, 1,-.618,1,0,-.81,1,-0.789,1.67,-1.34,0.67};
	//float32_t arm_biquad_coefs[] = {0.0059, 1.618, 0.0059, 1.5371, -0.9025, 1.0,-.618,1.0,0,.81,1.0,-0.789,1.67, 1.34,-0.67};
	
	float32_t arm_biquad_coefs[] = {
0.0145, 0.019942285, .01047625, 0.200533, -0.64,
1, -1.7119, 0.81, 1.09097, -0.7921,
1, -1.65831, 0.9801, 1.05775, -0.808201,
1, 1.0345, 0.7744, -0.0472446, -0.8836};
	float biquad_coefs[] = {
1, 1.37533, 0.7225, -0.200533, 0.64,
1, -1.7119, 0.81, -1.09097, 0.7921,
1, -1.65831, 0.9801, -1.05775, 0.808201,
1, 1.0345, 0.7744, 0.0472446, 0.8836};	
	float32_t g = 0.0145;
	int sections = 4;
	uint8_t numStages = 4;

	BIQUAD_T *s = init_biquad(sections, g, biquad_coefs, nsamp);
	
	float32_t *pState = (float32_t *)calloc(2*numStages, sizeof(float32_t));

	arm_biquad_cascade_df2T_instance_f32 armS;
	arm_biquad_cascade_df2T_init_f32(&armS, numStages, arm_biquad_coefs, pState);

	if (input==NULL || output1==NULL || output2==NULL||pState==NULL) {
    flagerror(MEMORY_ALLOCATION_ERROR);
    while(1);
  }

  /*
   * Normally we avoid printf()... especially once we start actually
   * processing streaming samples.  This is here to illustrate the
   * use of printf for debugging programs.
   *
   * To see the printf output, connect to the ST-Link serial port.
   * Use: 115200 8N1
   */
//  printf("Starting execution using %d samples per input block.\n",nsamp);

  /*
   * Infinite Loop to process the data stream, "nsamp" samples at a time
   */
  while(1){
    /*
     * Ask for a block of ADC samples to be put into the working buffer
     *   getblock() will wait here until the input buffer is filled...  On return
     *   we work on the new data buffer... then return here to wait for
     *   the next block
     */
    getblock(input);

    /*
     * signal processing code to calculate the required output buffers
     */

    DIGITAL_IO_SET(); 	// Use a scope on PD0 to measure execution time

    	arm_biquad_cascade_df2T_f32(&armS, input, output1, nsamp);
	calc_biquad(s, input, output2);

    DIGITAL_IO_RESET();	// (falling edge....  done processing data )

    /*
     * pass the processed working buffer back for DAC output
     */
    putblockstereo(output2, output1);

  }
//  destroy_biquad(s);
}
